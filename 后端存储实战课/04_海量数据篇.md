# 海量数据篇

## 15 | MySQL存储海量数据的最后一招：分库分表

只有 MySQL 这类关系型数据库，才能提供金融级的事务保证。

### 如何规划分库分表？

在考虑到底是分库还是分表之前，我们需要先明确一个原则，那就是能不拆就不拆，能少拆不多拆。原因也很简单，你把数据拆分得越散，开发和维护起来就越麻烦，系统出问题的概率就越大。

那我们分库分表的目的是为了解决两个问题：
- 第一，是数据量太大查询慢的问题。解决查询慢，只要减少每次查询的数据总量就可以了，也就是说，分表就可以解决问题。
- 第二，是为了应对高并发的问题。应对高并发的思想我们之前也说过，一个数据库实例撑不住，就把并发请求分散到多个实例中去，所以，解决高并发的问题是需要分库的。

简单地说，数据量大，就分表；并发高，就分库。

现在技术和业务变化这么快，等真正到了那个时候，业务早就变了，可能新的技术也出来了，你之前设计的二次扩容方案大概率是用不上的，所以没必要为了这个而增加方案的复杂程度。还是那句话，越简单的设计可靠性越高。

### 如何选择 Sharding Key？

选择合适 Sharding Key 和分片算法非常重要，直接影响了分库分表的效果。我们首先来说如何选择 Sharding Key 的问题。

选择这个 Sharding Key 最重要的参考因素是，我们的业务是如何访问数据的。

所以我们在之前的课程中，先讲了各种各样的方法，来缓解数据多、并发高的问题，而一直没讲分库分表。分库分表一定是，数据量和并发大到所有招数都不好使了，我们才拿出来的最后一招。

### 如何选择分片算法

还有一种分片的方法：查表法。查表法其实就是没有分片算法，决定某个 Sharding Key 落在哪个分片上，全靠人为来分配，分配的结果记录在一张表里面。每次执行查询的时候，先去表里查一下要找的数据在哪个分片中。

我们常用三种分片算法，范围分片容易产生热点问题，但对查询更友好，适合适合并发量不大的场景；哈希分片比较容易把数据和查询均匀地分布到所有分片中；查表法更灵活，但性能稍差。

## 16 | 用Redis构建缓存集群的最佳实践有哪些？

之前连续几节课，我们都在以 MySQL 为例子，讲如何应对海量数据，如何应对高并发，如何实现高可用，我先带你简单复习一下。
- 数据量太大查询慢怎么办？存档历史数据或者分库分表，这是数据分片。
- 并发太高扛不住怎么办？读写分离，这是增加实例数。
- 数据库宕机怎么办？增加从节点，主节点宕机的时候用从节点顶上，这是主从复制。但是这里面要特别注意数据一致性的问题

### Redis Cluster 如何解决数据量大、高可用和高并发问题？

Redis Cluster 相比于单个节点的 Redis，能保存更多的数据，支持更多的并发，并且可以做到高可用，在单个节点故障的情况下，继续提供服务。

分片可以解决 Redis 保存海量数据的问题，并且客观上提升了 Redis 的并发能力和查询性能。但是并不能解决高可用的问题，每个节点都保存了整个集群数据的一个子集，任何一个节点宕机，都会导致这个宕机节点上的那部分数据无法访问。

那 Redis Cluster 是怎么解决高可用问题的？

参见上面我们讲到的方法：增加从节点，做主从复制。Redis Cluster 支持给每个分片增加一个或多个从节点，每个从节点在连接到主节点上之后，会先给主节点发送一个 SYNC 命令，请求一次全量复制，也就是把主节点上全部的数据都复制到从节点上。全量复制完成之后，进入同步阶段，主节点会把刚刚全量复制期间收到的命令，以及后续收到的命令持续地转发给从节点。

### 为什么 Redis Cluster 不适合超大规模集群？

Redis Cluster 是非常适合构建中小规模 Redis 集群，这里的中小规模指的是，大概几个到几十个节点这样规模的 Redis 集群。

但是 Redis Cluster 不太适合构建超大规模集群，主要原因是，它采用了去中心化的设计。

在集群规模太大的情况下，数据不同步的问题会被明显放大，还有一定的不确定性，如果出现问题很难排查。

### 如何用 Redis 构建超大规模集群？

## 17 | 大厂都是怎么做MySQL to Redis同步的?

### 缓存穿透：超大规模系统的不能承受之痛

对于像订单服务这类核心的业务，一个可行的方法是，我们启动一个更新订单缓存的服务，接收订单变更的 MQ 消息，然后更新 Redis 中缓存的订单数据

所以，必须保证整个消息链条的可靠性，不过好在现在的 MQ 集群，比如像 Kafka 或者 RocketMQ，它都有高可用和高可靠的保证机制，只要你正确配置好，是可以满足数据可靠性要求的。

### 使用 Binlog 实时更新 Redis 缓存

数据更新服务只负责处理业务逻辑，更新 MySQL，完全不用管如何去更新缓存。负责更新缓存的服务，把自己伪装成一个 MySQL 的从节点，从 MySQL 接收 Binlog，解析 Binlog 之后，可以得到实时的数据变更信息，然后根据这个变更信息去更新 Redis 缓存。

对于缓存数据更新的方法，可以订阅数据更新的 MQ 消息来异步更新缓存，更通用的方法是，把缓存更新服务伪装成一个 MySQL 的从节点，订阅 MySQL 的 Binlog，通过 Binlog 来更新 Redis 缓存。

需要特别注意的是，无论是用 MQ 还是 Canal 来异步更新缓存，对整个更新服务的数据可靠性和实时性要求都比较高，数据丢失或者更新慢了，都会造成 Redis 中的数据与 MySQL 中数据不同步。在把这套方案应用到生产环境中去的时候，需要考虑一旦出现不同步问题时的降级或补偿方案。

## 18 | 分布式存储：你知道对象存储是如何保存图片文件的吗？

对象存储之所以能做到这么“全能”，最主要的原因是，对象存储是原生的分布式存储系统。

随着云计算的普及，很多新生代的存储系统，都是原生的分布式系统，它们一开始设计的目标之一就是分布式存储集群，比如说Elasticsearch、Ceph和国内很多大厂推出的新一代数据库，大多都可以做到：
- 近乎无限的存储容量；
- 超高的读写性能；
- 数据高可靠：节点磁盘损毁不会丢数据；
- 实现服务高可用：节点宕机不会影响集群对外提供服务

### 对象存储数据是如何保存大文件的？

对象存储对外提供的服务，其实就是一个近乎无限容量的大文件 KV 存储，所以对象存储和分布式文件系统之间，没有那么明确的界限。对象存储的内部，肯定有很多的存储节点，用于保存这些大文件，这个就是数据节点的集群。

## 19 | 跨系统实时同步数据，分布式事务是唯一的解决方案吗？

### 如何保证数据同步的实时性

我们知道，MySQL 主从同步 Binlog，是一个单线程的同步过程。为什么是单线程？原因很简单，在从库执行 Binlog 的时候，必须按顺序执行，才能保证数据和主库是一样的。为了确保数据一致性，Binlog 的顺序很重要，是绝对不能乱序的。

也就是说，我们只要保证每个订单的更新操作日志的顺序别乱就可以了。这种一致性要求称为因果一致性（Causal Consistency），有因果关系的数据之间必须要严格地保证顺序，没有因果关系的数据之间的顺序是无所谓的。

## 20 | 如何在不停机的情况下，安全地更换数据库？

## 21 | 类似“点击流”这样的海量数据应该如何存储？

## 22 | 面对海量数据，如何才能查得更快?\

## 23 | MySQL经常遇到的高可用、分片问题，NewSQL是如何解决的？

## 24 | RocksDB：不丢数据的高性能KV存储

## 结束语 | 把奋斗当习惯

### 把奋斗当成习惯

为什么会有这样的现象？因为如果没有足够的技术积累，你很难理解书本上的技术知识和原理它的用途在哪儿，所以会觉得没用。只有你遇到过这样的问题，有过困惑，再去看书上讲的知识，立刻就会有一种恍然大悟的感觉。所以说，原始的技术积累非常重要。

对于技术积累，没有捷径可以走，如果想做到快速积累，只有多写代码、多做项目这一条路。具体的做法很简单，也很难，就是去主动地去多做事情，不要去管这些事情是不是职责范围内的、有没有报酬、会不会有收获、对技术有没有提升。不计得失，任劳任怨。

这个做法说来简单，它真的就很简单，只要想去做，每个人都做得到。但是，它也很难。因为并不是每个人都打心里认同这个做法，如果你没有内心的认同，又强迫自己这么做，是非常痛苦的，并且很难坚持下来。所以，问题的关键是寻求内心的认同。

我刚毕业那几年，对这个观点就是非常不认同。我当时的想法是这样的：每个月才给我这么一点儿钱，凭啥我要主动去做这么多事儿？我对公司产生的价值，绝对对得起我的工资，再多干活，公司又不会给我钱。

我估计很多年轻的朋友也会有同样的想法。我们不能说这个想法就不对，实际上这里面涉及到人生观的问题。比如说，有的人清楚地知道自己想要什么，“我不追求什么技术，也不在乎职务收入，工作只是我谋生的手段，我更看重的是诗和远方”。

但我是一个“俗人”，希望不断提升自身的技术能力，获得自我认同，同时也获得更好的收入和体面的生活。如果你也和我一样不能免俗的话，我建议你在内心上尽快做一个转变。什么转变呢？从“凭什么要我做？”，到“愿意主动去多做事儿”，再到“把奋斗当做习惯”。

其实你真正应该较劲的人，不是那个扣扣索索不舍得给你发钱的老板，而是那些和你一起竞争有限发展空间的同龄人。主动去多做一些事儿，不仅能获得更多的成长和锻炼，更重要的是获得周围人对你的认同，这里面也包括你的领导和老板。这样你就会获得更重要的任务和更多的锻炼机会，才能相比同龄人更快速地成长，用更短的时间快速实现技术积累。

所以，停下来，去思考沉淀，让点成势，构建出自己的知识结构，是技术成长的捷径。

### 洞见技术本质

