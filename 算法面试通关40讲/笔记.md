# 笔记

1. 两数之和

## 数组，链表

206. 反转链表
24. 两两交换链表的节点
141. 判断链表是否有环

## 堆，栈

20. 有效的括号

225. 用队列实现栈 
232. 用栈实现队列

## 优先队列

堆，二叉搜索树
二叉堆，小顶堆，大顶堆

703. 实时判断数据流中最K大元素
NlogK

239. 滑动窗口最大值 todo
双端队列
最大值永远在左边

## 哈希表和集合

242. 有效字母的异位词
排序nlogn，map计数

1. 两数之和
15. 三数之和
暴力，set,排序

18. 四数之和
49. 字母异位词分组

## 树、二叉树、二叉搜索树

98. 验证二叉搜索树
中序遍历，递归

235. 二叉搜索树最小公共祖先
236. 二叉树最小公共祖先

## 二叉树的遍历

## 递归、分治

50. x的n次方
169. 求众数
暴力，map，sort,分治

53. 最大子序和
242. 有效的字母异位词
438. 找到字符串中所有字母异位词

## 贪心算法

122. 股票买卖
860. 柠檬水找零
455. 分发饼干
874. 模拟行走机器人

## DFS和BFS

102. 二叉树的层次遍历
BFS, DFS
图的话要额外记录visited集合

104. 树的最大深度
111. 树的最小深度
22. 括号生成

## 剪枝

51. N皇后
52. N皇后II
DFS，每一行，判断ij，是否满足列，撇，捺。撇的话i+j为确定值，捺的话i-j为确定值
遍历每一行，判断位置，放位置，递归，移除位置。归去来兮

36. 有效的数独
37. 解数独

## 二分查找

69. 求平方根
二分法，牛顿迭代法
367. 有效的完全平方数

## 字典树

Trie树，即字典树，⼜又称单词查找树或键树，是⼀一种树形结构，是⼀一种哈希树的变种。典型应⽤用是⽤用于统计和排序⼤大量量的字符串串（但不不仅限于字符串串），所以经常被搜索引擎系统⽤用于⽂文本词频统计。

它的优点是：最⼤大限度地减少⽆无谓的字符串串⽐比较，查询效率⽐比哈希表⾼高。

Trie的核⼼心思想是空间换时间。利利⽤用字符串串的公共前缀来降低查询时间的开销以达到提⾼高效率的⽬目的。

基本性质：

1. 根节点不不包含字符，除根节点外每⼀一个节点都只包含⼀一个字符。
2. 从根节点到某⼀一节点，路路径上经过的字符连接起来，为该节点对应的字符串串。
3. 每个节点的所有⼦子节点包含的字符都不不相同。

208. 实现 Trie (前缀树)
79. 单词搜索I
212. 单词搜索 II
DFS，

## 位运算

191. 统计位1的个数
移位操作，x&x-1
231. 2的幂
x&x-1 == 0
338. 比特位计数
count[i] = count[i&(i-1)] + 1
52. N皇后 II
位运算的解法没看懂

## 动态规划

1. 递归+记忆化 —> 递推
2. 状态的定义：opt[n], dp[n], fib[n]
3. 状态转移⽅方程：opt[n] = best_of(opt[n-1], opt[n-2], …)
4. 最优⼦子结构

动态规划 vs 回溯 vs 贪心算法

- 回溯（递归）— 重复计算
- 贪⼼心算法 — 永远局部最优
- 动态规划 — 记录局部最优⼦子结构 / 多种记录值

动态规划自己的人生，得到全局最优解

70. 爬楼梯
f(n) = f(n-1) + f(n-2)
120. 三角形的最小路径和
人生千万不要用贪心法
dp[i,j] = min(dp(i+1,j), dp(i+1,j)) + triangle[i,j]
152. 乘积最大子序列 !
a[i]为正，dp[i] = dp[i-1] * a[i]
否则：dp[i] 另一个dp
121,122,123,309,188,714
股票买卖系列

1次，无数次，2次，k次
MP[i] 到了第i天的最大利润
MP[i] = MP[i-1] + (-a[i]) 买股票
MP[i] = MP[i-1] + (a[i]) 卖股票
状态不够，增加一维
MP[i][j][k]

300. 最长上升子序列
暴力 2^n
双层循环，max(DP) O（n^2）
二分查找 O(nlogn), 很精彩，值得学习
11,12,13,14,1,2,3
[11,12,13,14]
[1,12,13,14]

322. 零钱兑换
朴素的贪心没法解决，1,6,7 30
DP[i] = min{DP[i-coins[j]]} + 1
时间复杂度：O(xn)

72. 编辑距离
dp[i][j]
i:word1的前i个字符
j:word2的前j个字符
DP[i][j]
if w1[i] == w2[j] dp[i][j] = dp[i-1][j-1]
if w1[i] != w2[j] dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1
O(m*n)

## 并查集

200. 岛屿个数
染色。遍历节点，如果是1，数目加一，周围附近节点都染色
并查集
初始化，针对1的节点
遍历所有节点，相邻合并，统计有多少老大

547. 朋友圈

## LRU cache

least recently used
双向链表
查询 O(1)
修改，更新O(1)

146. LRU cache

## 布隆过滤器

判断不在，百分之百不在
判断在，可能会不在

二进制

⼀一个很⻓长的⼆二进制向量量和⼀一系列列随机映射函数。布隆隆过滤器器可以
⽤用于检索⼀一个元素是否在⼀一个集合中。它的优点是空间效率和查
询时间都远远超过⼀一般的算法，缺点是有⼀一定的误识别率和删除
困难。

案例
1. 比特币网络
2. 分布式系统（Map-Reduce）

## 重点回顾

位运算操作
1. X & 1 == 1 OR == 0 判断奇偶 (X % 2 == 1)
2. X = X & (X-1) => 清零最低位的 1
3. X & -X => 得到最低位的 1

持续练习 + 精深练习（刻意练习）
1. 除了了“做熟悉和会做的题⽬目”之外，去刻意练习⾃自⼰己不不熟悉的算法和数据结构。
不不要为了了切题⽽而切题
2. 做过的题⽬目后续要返回再复习

面试答题四件套
1. Clarification（询问题目细节、边界条件、可能的极端错误情况）
2. Possible Solution（所有可能的解法都和面试官沟通一遍）
• Compare Time & Space Complexity（时间复杂度&空间复杂度）
• Optimal Solution（最优解）
3. Coding（写代码）
4. Test Cases（测试用例）

最后：沟通和交流很重要

斐波那契数列，可以用矩阵升维的思路

环境准备
1. Keyboard set-up
2. iTerms + Oh-my-zsh
3. IDE (Pycharm, IntelliJ, Webstorm, GoLand)
Editors (VS Code, Sublime, Atom, VIM, etc)

结束语
算法和数据结构是内⼒力力
重在练习（修⾏行行）

terminator
process
drill down
clear states

