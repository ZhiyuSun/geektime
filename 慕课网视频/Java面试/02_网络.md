# 网络

## OSI七层协议

物理层：比特流。网卡
数据链路层：如何格式化数据，确保数据传输可靠性，比特流组成帧。交换机
网络层：网络地址翻译成物理地址，数据包，IP协议。路由器
传输层：流量控制，TCP/UDP，分段
会话层：建立和管理应用程序员之间的通信
表示层：数据
应用层:HTTP

## TCP/IP

OSI的实现：TCP/IP

应用层：应表会  HTTP数据
传输层：传输层  TCP首部
网络层：网络层  IP首部
链路层：物数    以太网首部

## TCP三次握手

传输控制协议TCP简介：
- 面向连接的，可靠的，基于字节流的传输层通信协议
- 将应用层的数据流分隔成报文段并发送给目标节点的TCP层
- 数据包都有序号，对方收到则发送ACK确认，未收到则重传
- 使用校验和来检验数据在传输过程中是否有误

TCP报文头

TCP Flags
- URG：紧急指针标志
- ACK：确认序号标志
- SYN：同步序号，用于建立连接过程
- FIN：finish标志，用于释放连接

握手是为了建立连接，TCP三次握手的流程图如下：
在TCP/IP协议中，TCP协议提供可靠的连接服务，采用三次握手建立一个连接。
第一次握手：建立连接时，客户端发送SYN包（syn=j）到服务器，并进入SYN_SEND状态，等待服务器确认；
第二次握手：服务器收到SYN包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；
第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK（ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。

为什么需要三次握手才能建立起连接？
为了初始化Sequence Number的初始值

## TCP的四次挥手

挥手是为了终止连接，TCP四次挥手的流程图如下
第一次挥手：Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态
第二次挥手：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态
第三次挥手：Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态；
第四次挥手：Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手

这几个状态图要弄清楚

为什么会有TIME_WAIT状态？
- 确保有足够的时间让对方收到ACK包
- 避免新旧连接混淆

为什么需要四次挥手才能断开连接？
- 因为全双工，发送方和接收方都需要FIN报文和ACK报文

服务器出现大量CLOSE_WAIT状态的原因
- 对方关闭socket连接，我方忙于读或写，没有及时关闭连接
    - 检查代码，特别是释放资源的代码
    - 检查配置，特别是处理请求的线程配置（可用netstat排查）

## UDP

特点
- 面向非连接
- 不维护连接状态，支持同时向多个客户端传输相同的消息
- 数据包报头只有8个字节，额外开销较小
- 吞吐量只受限于数据生成速率、传输速率以及机器性能
- 尽最大努力交付，不保证可靠交付，不需要维持复杂的链接状态表
- 面向报文，不对应用程序提交的报文信息进行拆分或者合并

## TCP和UDP的区别

结论：
- 面向连接VS无连接
- 可靠性
- 有序性
- 速度
- 量级

## TCP的滑动窗口

RTT和RTO:
- RTT：发送一个数据包到收到对应的ACK，所花费的时间
- RTO：重传时间间隔

TCP使用滑动窗口做流量控制与乱序重排
- 保证TCP的可靠性
- 保证TCP的流控特性

这个有点难

## HTTP简介

特点：
- 支持客户/服务器模式
- 简单快速
- 灵活
- 无连接
- 无状态

面试以1.1为准

http1.1 keep-alive

请求/响应步骤：
- 客户端连接到web服务器
- 发送HTTP请求
- 服务器接受请求并返回HTTP响应
- 释放TCP连接
- 客户端浏览器解析HTML内容

在浏览器地址栏键入URL，按下回车之后经历的流程
- DNS解析
- TCP连接。和服务建立
- 发送HTTP连接
- 服务器处理请求并返回HTTP报文
- 浏览器解析渲染页面
- 连接结束

HTTP状态码
- 1xx：指示信息——表示请求已接收，继续处理
- 2xx：成功——表会请求已被成功接收、理解、接受
- 3xx：重定向——要完成请求必须进行更进一步的操作
- 4xx：客户端错误——请求有语法错误或请求无法实现
- 5xx：服务端错误——服务器未能实现合法的请求

GET请求和POST请求的区别
- HTTP报文层面：GET将请求信息放在URL,POST放在请求体里面
- 数据库层面：GET符合幂等性和安全性，POST不符合
- 其他层面：GET可以被缓存、被存储，而POST不行

Cookie和Session的区别
- Cookie
    - 是由服务器发给客户端的特殊信息，以文本的形式存放在客户端
    - 客户端再次请求的时候，会把cookie回发
    - 服务器接收到后，会解析Cookie生成与客户端相对应的内容
- Session的简介
    - 服务器端的机制，在服务器上保存的信息
    - 解析客户端请求并操作session id，按需保存状态信息
- Session的实现方式
    - 使用Cookie来实现（JSESSIONID）
    - 使用URL回写来实现
- Cookie和Session的区别
    - Cookie数据存放在客户的浏览器上，Session数据放在服务器上
    - Session相对于Cookie更安全
    - 若考虑减轻服务器负担，应当使用Cookie

## HTTP和HTTPS的区别

SSL（Security Sockets Layer，安全套接层）
- 为网络通信提供安全及数据完整性的一种安全协议
- 是操作系统对外的API，SSL3.0后更名为TLS
- 采用身份验证和数据加密保证网络通信的安全和数据的完整性

加密的方式
- 对称加密：加密和解密都使用同一个密钥
- 非对称加密：加密使用的密钥和解密使用的密钥是不相同的
- 哈希算法：将任意长度的信息转换为固定长度的值，算法不可逆
- 数字签名：证明某个消息或者文件是某人发出/认同的

HTTPS数据传输流程
- 浏览器将支持的加密算法信息发送给服务器
- 服务器选择一套浏览器支持的加密算法，以证书的形式回发浏览器
- 浏览器验证证书合法性，并结合证书公钥加密信息发送给服务器
- 服务器使用私钥解密信息，验证哈希，加密响应消息回发浏览器
- 浏览器解密响应消息，并对消息进行验真，之后进行加密交互数据

HTTP和HTTPS的区别
- HTTPS需要CA申请证书，HTTP不需要
- HTTPS密文传输，HTTP明文传输
- 连接方式不同，HTTPS默认使用443端口，HTTP使用80端口
- HTTPS=HTTP+加密+认证+完整性保护，较HTTP安全

Socket简介
（pid是本地唯一继承
IP地址+协议+端口号）
Socket是对TCP/IP协议的抽象，是操作系统对外开放的接口

Socket通信流程

Socket相关的面试题，javabasic.socket