# GC

## 对象被判定位垃圾的标准

没有被其他对象引用

引用计数法
- 优点：执行效率高，程序执行受影响较小
- 缺点：无法检测出循环引用的情况，导致内存泄露

可达性分析算法
通过判断对象的引用链是否可达来决定对象是否可以被回收
gc root

可以作为gc root的对象
- 虚拟机栈中引用的对象（栈帧中的本地变量表）
- 方法区中的常量引用的对象
- 方法区中的类静态属性引用的对象
- 本地方法栈找那个JNI（Native方法）的引用对象
- 活跃线程的引用对象

## 谈谈你了解的垃圾回收算法

标记-清除算法（mark and sweep）
- 碎片化

复制算法（copying）
- 解决碎片化问题
- 顺序分配内存，简单高效
- 适用于对象存活率低的场景

标记-整理算法（compacting）
- 避免内存的不连续性
- 不用设置两块内存互换
- 适用于存活率高的场景

分代收集算法
- 垃圾回收算法的组合拳
- 按照对象生命周期的不同划分区域以采用不同的垃圾回收算法
- 目的：提供JVM的回收效率

## GC的分类

minor GC
Full GC

年轻代：尽可能快速地收集掉那些生命周期短的对象
- eden区
- 两个survivor区
- 8:1:1
- 年轻代：老年代=1:2

对象如何晋升到老年代
- 经历一定Minor次数依然存活的对象
- survivor区存放不下的对象
- 新生成的大对象

常用的调优参数
- XX:SurvivorRatio:Eden和Survivor的比值，默认8:1
- XX:NewRatio:老年代和年轻代内存大小的比例
- XX:MaxTenuringThreshold：对象从年轻代晋升到老年代经过GC次数的最大阈值

老年代：存放生命周期较长的对象
- 标记-清理
- 标记-整理
- full gc和major gc
- full gc比minor gc慢，但执行频率低

触发full gc的条件：
- 老年代空间不足
- cms gc...
- minor gc晋升到老年代的平均大小大于老年代的剩余空间
- system.gc()
- 使用RMI来进行RPC或管理的jdk应用

stop-the-world
- JVM由于要执行GC而停止了应用程序的执行
- 任何一种GC算法中都会发生
- 多数GC优化通过减少stw发生的时间来提高程序性能

## 常见的垃圾收集器

serial收集器（client）
ParNew收集器(多核下执行有优势)
Parallel Scavenge收集器（吞吐量，更关注系统的吞吐量）

老年代
serial old收集器
Parallel Old收集器
CMS收集器（标记-清除算法）
G1收集器（并行和并发，分代收集，空间整合，可预测的停顿）

## Java中的强引用，软引用，弱引用，虚引用


## 找工作的渠道

最为推荐的一种
- 简历直达团队，避免被非团队的人员筛掉
- 知己知彼
- 避免简历被锁
- 注意：碍于情面，错过后面的好公司

招聘网站的投递，最不推荐的一种
- 简历会被锁定
- 太多的虚假信息

猎头招聘
- 人性最真实的一面
- 猎头对特定的公司、职位比较熟悉
- 找干练的猎头：是否做到精准推送，建议是否足够好
- 找多个猎头，多方面了解市场
- 做好恶战的准备
- 搭线练手公司，查漏补缺

找工作的渠道总结
- 利用猎头对公司进行分类：练手公司和心仪公司
- 竭尽全力挖掘目标公司的内部员工

