# 进程和线程

## 进程和线程的区别

进程是资源分配的最小单位，线程是CPU调度的最小单位
- 所有与进程相关的资源，都被记录在PCB中
- 进程是抢占处理机的调度单位；线程属于某个进程，共享其资源
- 线程只由堆栈寄存器、程序计数器和TCB组成

总结：
- 线程不能看做独立应用，而进程可看做独立应用
- 进程有独立的地址空间，相互不影响，线程只是进程的不同执行路径
- 线程没有独立的地址空间，多进程的程序比多线程程序健壮
- 进程的切换比线程的切换开销大

## Java进程和线程的关系

- Java对操作系统提供的功能进行封装，包括进程和线程
- 运行一个程序会产生一个进程，进程包含至少一个线程
- 每个进程对于一个JVM实力，多个线程共享JVM里的堆
- Java采用单线程编程模型，程序会自动创建主线程
- 主线程可以创建子线程，原则上要后于子线程完成执行

## 线程的run和start的区别

调用start方法会常见一个新的子线程并启动
run方法只是Thread的一个普通方法的调用

## Thread和Runnable是什么关系

Thread是实现了Runnable接口的类，使得run支持多线程
因类的单一继承原则，推荐多使用Runnable接口

## 如何给run()方法传参
- 构造函数传参
- 成员变量传参
- 回调函数传参

## 如何实现处理线程的返回值
实现方式有三种
- 主线程等待法（while循环等待）
- 使用Thread类的join（）阻塞当前线程以等待子线程处理完毕
- 通过Callable接口实现：通过FutureTask Or 线程池获取

## 线程的状态

- 新建（New）：创建后尚未启动的线程的装填
- 运行（Runnable）:包含Running和Ready
- 无限期等待（Waiting）:不会被分配CPU执行时间，需要显示的被唤醒
    - 没有设置timeout参数的object.wait()方法
    - 没有设置timeout参数的Thread.join()方法
    - LockSupport.part()方法
- 限期等待（Timed Waiting）:在一定时间后会由系统自动唤醒
    - Thread.sleep方法
    - 设置了timeout参数的object.wait()方法
    - 设置了timeout参数的Thread.join()方法
    - LockSupport.parkNanos()方法
    - LockSupport.parkUntil()方法
- 阻塞（blocked）:等待获取排他锁
- 结束（terminated）：已终止线程的状态，线程已经结束执行

## sleep和wait的区别

sleep是Thread类的方法，wait是Object类中定义的方法
sleep方法可以在任何地方使用
wait方法只能在synchronized方法或者synchronized块中使用

最主要的本质区别
- Thread.sleep只会让出cpu，不会导致锁行为的改变
- object.wait不仅让出cpu，还会释放已经占有的同步资源锁

## notify和notifyAll的区别

notifyAll会让所有处于等待池的线程全部进入锁池去竞争获取锁的机会
notify只会随机选取一个处于等待池中的线程进入锁池去竞争获取锁的机会

## 如何中断线程

调用interrupt（）,通知线程应该中断了
- 调用interrupt，通知线程应该中断了
    - 如果线程处于被阻塞的状态，那么线程将立即退出被阻塞状态，并抛出一个InterruptedException异常
    - 如果线程处于正常活动状态，那么会将该线程的中断标志设置为True。被设置中断标志的线程将继续正常运行，不受影响。
- 需要被调用的线程配合中断
    - 在正常运行任务时，经常检查本线程的中断标志位，如果被设置了中断标志就自行停止线程
    - 如果线程处于正常活动状态，那么会将该线程的中断标志设置为true。被设置中断标志的线程将继续正常运行，不受影响。

## 如何有效地让薪资更上一层楼

增加自己的筹码
- 尽量打听公司岗位职位的薪酬幅度
- 感知目标公司的缺人程度，工作的紧急程度
- 最有效的方式是已经具备了有竞争力的offer

