# 数据库优化

## 为什么要进行数据库优化？

避免网站页面出现访问错误

- 数据库连接timeout产生页面5xx错误
- 慢查询造成页面无法加载
- 阻塞造成数据无法提交

增加数据库的稳定性

- 很多数据库问题都是由于低效的查询引起的（忘记索引）
- 随着时间的退役，系统变得极其臃肿，数据库中的数据量越来越大，数据检索越来越困难，对整个系统带来的资源消耗也就越来越大，系统越发不稳定

优化用户体验

- 流程的页面访问速度
- 良好的网站功能体验

## 数据库优化层面

硬件
系统配置
数据库表结构
SQL及索引
系统架构
商业需求

越往上，成本高，越往下，效果高

### 商业需求

- 不合理需求造成资源投入产出比过低
    - 比如：热门帖子，需要实时更新吗
- 无用功能堆积使系统过度复杂影响整体性能

### 系统架构

- 数据库中存放的数据都是适合在数据库中存放的吗？
    - 比如多媒体数据，流水数据
- 是否合理的利用了应用层Cache机制？
    - 不太变动的，经常访问的，放在redis里
- 数据层实现都是精简的吗？

### SQL及索引优化

- 根据需求写出良好的SQL，并创建有效的索引，实现某一种需求可以多种写法，我们就要选择一种效率最高的写法，这个时候就要了解sql优化
- sql优化的目的之一就是减少中间结果集，降低物理IO
    - 如何优化select t1.id, t2.name from t1,t2 where t1.pid=t2.pid
    - 上面这条的io次数就是两张表的笛卡尔积，需要改成join on的写法

### 数据库表结构优化

- 根据数据库的范式，设计表结构，表结构设计的好坏直接关系到SQL语句的复杂度
- 适当的将表进行拆分，原本需要做join的查询只需要一张单表查询就可以了

### 系统配置优化

- 大多数运行在linux机器上，如tcp连接数的限制，打开文件数的限制，安全性的限制，因此我们要对这些配置进行相应优化。
    - 运维的同学肯定会，有长期积累的脚本


### 硬件配置优化

- 数据库主机的IO性能是需要最优先考虑的一个因素
- 数据库主机和普通的应用程序服务器想比，资源要相对集中很多，单台主机上所需要的进行的计算量自然也就比较多，所以数据库主机的CPU处理能力也是一个重要的因素。
- 数据库主机的网络设备（一般值网卡等）的性能也可能会成为系统的瓶颈

## SQL及索引优化

现在互联网公司因为敏捷开发模式，都很少有文档了

show variables like '%slow_query_log%';

set global slow_query_log=on;

show variables like 'long_query_time';

select  sleep(11); 日志进来了

日志格式解析：
- query_time 这条SQL的执行时长
- lock_time 在MySQL服务器阶段等待表锁时间
- Rows_sent 查询返回的行数
- Rows_examined 查询检查的行数，越长久当然越费时间

rows_sent和rows_examined不能相差太大

可以用jmeter给mysql做压测

## MySQL慢查询日志分析工具

### mysqldumpslow 分析慢查询的日志

找到最慢的sql

缺点：统计的信息比较少，比如cpu，io信息都没有

### pt-query-digest

第三方工具

pt-summary
pt-diskstats
pt-query-digest  重点掌握慢查询日志分析工具
pt-slave-find
pt-deadlock-logger
pt-index-usage
pt-ioprofile
pt-config-diff
pt-find
pt-show-grants
pt-table-checksum

### 三大类有问题的SQL

查询次数多且每次查询占用时间长的sql
IO大的SQL，关注rows examine项
未命中的索引SQL，rows examine和rows send的对比
- examine是检测的，send是发给客户端的

## 使用explain查询SQL的执行计划

在SQL之前加explain

id,
select_type 简单查询，复杂查询
table，设计到的表
paritions 分区
type all全表扫描
possible_keys 可能使用的索引
key 用到的索引
key_len 索引长度
ref 索引在那一列上面
rows 检查行数
filtered 百分比

### 执行计划的字段解释与举例

1. id

数字越大越先执行，如果数字一样大，那么就从上往下依次执行，id列为null就表示这是一个结果集，不需要使用它来进行查询

2. select_type列

simple: 表示不需要union操作或者不包含子查询的简单select查询，有连接查询时，外层的查询为simple，且只有一个。

primary：一个需要union操作或者含有子查询的select（复杂查询），位于最外层的查询，select_type即为primary，且只有一个

union：union连接的两个select查询，第一个查询是dervied派生表，除了第一个表外，第二个以后的表select_type都是union

union result: 包含union的结果集，在union和union all语句中，因为它不需要参与查询，所以id字段为null

dependent union： 与union一样，出现在union或union all语句中，但是这个查询要受到外部查询的影响

subquery: 除了from子句中包含的子查询外，其他地方出现的子查询都可能是subquery

dependent subquery: 与dependent union类似，表示这个subquery的查询要受到外部表查询的影响

derived: from子句中出现的子查询，也叫做派生表，其他数据库中可能叫做内联视图或嵌套select

materialization: 物化通过将子查询结果作为一个临时表来加快查询执行速度，正常来说是常驻内存，下次查询会再次引入临时表。

3. table 

显示的查询表名，如果查询使用了别名，那么显示别名，如果不涉及对数据表的操作，那么显示为null，如果显示为<derived N> 就表示这个是临时表，后面的N就是执行计划中的id，表示结果来自于这个查询产生。如果是<union M,N>，也是一个临时表，表示结果来自于union查询的id为M,N的结果集

4. type

system：表中只有一行数据或者空表，且只能用于myisamh和memory表，如果是innodb，type通常是all或index

const: 使用唯一索引或者主键，返回记录一定是1行记录的等值where条件时，通常type是const

eq_ref：出现在要连接多个表的查询计划中，驱动表循环获取数据，转行数据是第二个表的主键或者唯一索引，作为条件查询只返回一条数据，且必须为not null，唯一索引和主键是多列时，只有所有的列都用作比较时才会出现eq_ref

select xx left join yy , xx是驱动表，xx记录越少越好

ref: 不像eq_ref那样要求连接顺序，也没有主键和唯一索引的要求，只要使用相等条件检索时就可能出现，常见与辅助索引的等值查找或者多列主键、唯一索引中，使用第一个列之外的列作为等值查找也会出现，总之，返回数据不唯一的等值查找就可能出现。

fulltext：全文索引检索，全文索引的优先级比较高

ref_or_null

unique_subquery

index_subquery

range

index_merge

index

all：全表扫描

总结：
依次性能从好到差：system,const,eq_ref,ref,fulltext,ref_or_null,unique_subquery,index_subquery,range,index_merge,index,all，除了all之外，其他的type都可以使用到索引，除了index_merge，其他的type只可以用到一个索引。
一般来说，好的sql查询至少达到range级别，最好能达到ref。

5. possible keys 可能用到的索引

6. keys 真正用到的索引

查询真正使用到的索引，select_type为index_merge时，这里可能出现两个以上的索引，其他的select_type这里只会出现一个。

7. key_len列

用于处理查询的索引长度

8. ref列

如果是使用的常熟等值查询，这里会显示const
如果是连接查询，被驱动表的执行计划这里会显示驱动表的关联字段，
如果是条件使用了表达式或者函数，或者条件列发生了内部隐式转换，这里可能显示为func

9. rows列

这里是执行计划中估算的扫描行数，不是精确值

10. extra列

no table used：不带from子句的查询或者from dual查询
null：查询的列未被索引覆盖，并且where筛选条件是索引的前导列，意味着用到了索引，但是部分字段未被索引覆盖，必须通过会标来实现，不是纯粹的用到了索引，也不是完全没用到索引。
using index: 查询时不需要回表查询，直接通过索引就可以获取查询的数据
using where：查询的列未被索引覆盖，where筛选条件非索引的前导列
using where using index
using index condition
using tempory
using filesort
using intersect
useing union
using sort_union
firstmatch

11. filtered

存储引擎返回的数据在server层过滤后，剩下多少满足查询的记录数量的比例，注意是百分比，不是具体记录数






