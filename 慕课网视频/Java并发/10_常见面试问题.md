# 常见面试问题

## 1. 有多少中实现线程的方法？思路有5点

1. 从不同的角度看，还有不同的答案
2. 典型答案是两种
3. 我们看原理，两种本质都是一样的
4. 具体展开说其他方式
5. 结论

## 2. 实现Runnable接口和继承Thread类哪种方式更好？

1. 从代码架构角度
2. 新建线程的损耗
3. Java不支持双继承

## 3. 一个线程两次调用start()方法会出现什么情况？为什么？

先去检查状态

## 4. 既然start()方法会调用run()方法，为什么我们选择调用start()方法，而不是直接调用run()方法呢？

调用start方法才是真正意义上启动一个线程，去经历线程的各个生命周期，
而如果直接调用run方法，它就是一个普通的方法而已，不会用子线程去调用

### 5. 如何停止线程

- 原理：用interrupt来请求、好处
- 想停止线程，要请求方、被停止方、子方法被调用方相互配合
- 最后再说错误的方法：stop/suspend已废弃，volatile的boolean无法处理长时间阻塞的情况

### 6. 如何处理不可中断的阻塞

- 没有通用的解决方案
- 针对特定的情况，使用特定的方法，没有万能药

### 7. 线程有哪几种状态？线程的生命周期是什么？

一幅图
6个状态，一个圈

### 8. 手写代码：两个线程交替打印0——100的奇偶数

基本思路：synchronized
更好的方法：wait/notify

### 9. 手写生产者消费者设计模式

可以把面试官往我们熟悉的地方去引导

### 10. 为什么wait()需要在同步代码块内使用，而sleep()不需要

让通信变得可靠，避免死锁的发生，防止第二个线程notify了，但是第一个线程还没有走到wait

### 11. 为什么线程通信的方法wait(), notify() 和notifyAll()被定义在Object类里？而sleep定义在thread类里？

wait(), notify() 和notifyAll()是锁级别的操作，锁是属于对象的，而不是线程中
经常会遇到一种情况，每一个线程会持有多个锁，多个锁是可以相互配合的，可以支持更灵活的逻辑

### 12. wait方法是属于Object对象的，那调用Thread.wait会怎么样？

Thread类不适用于锁对象

### 13. 如何选择用notify还是notifyAll?

是唤醒一个线程还是多个线程

### 14. notifyAll之后所有的线程都会再次抢夺锁，如果某线程抢夺失败怎么办？

无非是陷入到等待的状态

### 15. suspend()和resume()来阻塞线程可以吗？为什么？

推荐用wait()和notify()实现休眠的功能

### 16. wait/notify 和sleep异同（方法属于哪个对象？线程状态怎么切换？）

相同
- 都会让线程进入阻塞状态（waiting，time_waiting）
- 都会响应中断

不同
- wait/notify必须在同步方法中执行（使线程更安全，防止死锁或永久等待），但是sleep不需要
- wait/notify会释放锁，但是sleep不释放
- wait不需要传参，sleep需要传入指定时间
- 所属类，wait属于Object（Java设计的是每一个类都是一把锁，它的对象头中有几位保存monitor的预留）, sleep属于Thread类

### 17. 在join期间，线程处于哪种线程状态

waiting

### 18. 守护线程和普通线程的区别

整体没多大区别，区别在于是否影响jvm的退出
用户线程是执行我们的逻辑的，守护线程是服务于我们的

### 19. 我们是否需要给线程设置为守护线程？

不应该，这会非常危险。否则可能会在操作过程中被jvm强行终止，jvm所提供的守护线程就足够服务于我们了。

### 20. 如何应用线程优先级来帮助程序运行？有哪些禁忌？

不应该设置优先级，不同的操作系统不一样

### 21. java异常是什么

### 22. 实际工作中，如何全局处理异常？为什么要全局处理？不处理行不行？

用UncoughtException

### 23. run方法是否可以抛出异常？如果抛出异常，线程的状态会怎么样？

可以，线程终止运行，打印出异常堆栈

### 24. 线程中如何处理某个未处理异常

全局处理器

### 25. 你知道有哪几类线程不安全的情况？

### 26. 平时哪些情况下需要额外注意线程安全问题？

### 27. 什么是多线程的上下文切换

### 28. JMM应用实例：单例模式8种写法、单例和并发的关系（真实面试超高频考点）

单例模式的作用：
- 为什么需要单例：节省内存和计算，保证结果正确（多线程统计），方便管理

单例模式适用场景：
- 无状态的工具类：比如日志工具列，不管是在哪里适用，我们需要的只是它帮我们记录日志信息，除此之外，并不需要在它的实例对象上存储任何状态，这时候我们就只需要一个实例对象即可。
- 全局信息类：比如我们在一个类上记录网站的访问次数，我们不希望有的访问被记录在对象A上，有的却记录在对象B上，这时候我们就让这个类成为单例

单例模式的8种写法
- 饿汉式（静态常量）（可用）
- 饿汉式（静态代码块）（可用）
- 懒汉式（线程不安全）（不可用）（用的时候再去创建）
- 懒汉式（线程安全，同步方法）（不推荐）（线程多个线程去创建单例，效率低下）
- 懒汉式（线程不安全，同步代码块）（不推荐）（会创建多个实例）
- 双重检查（推荐面试使用）
    - 优点：线程安全；延迟加载；效率较高
    - 为什么要double-check
        - 线程安全
        - 单check行不行？里面的判断可以防止创建多个实例
        - 性能问题。synchronized加在外面有性能问题，多个线程访问时不能及时响应
    - 为什么要用volatile
        - 新建对象实际上有3个步骤（construct empty resource(),assign to rs,call constructor。如果第一个线程还没有call constructor,第二个线程会拿到没有构造成功的rs，使用会出错）
        - 重排序会带来NPE
        - 防止重排序
- 静态内部类方式，可用
    - 实现的是懒汉的行为。线程安全+懒加载
- 枚举（推荐用）（生产实践中最佳写法） 

不同写法对比
- 饿汉：简单，但是没有lazy loading
- 懒汉：有线程安全问题
- 静态内部类：可用
- 双重检查：面试用
- 枚举：最好

用哪种单例的实现方案最好？
- Joshua Bloch大神在《Effective Java》中明确表达过的观点：使用枚举实现单例的方法虽然还没有广泛采用，但是单元素的枚举类型已经成为实现Singleton的最佳方法
- 写法简单
- 线程安全有保障（枚举是特殊的类，会被编译成finalclass）
- 懒加载
- 避免反序列化破坏单例

各种写法的适用场合
- 最好的方法是利用枚举，因为还可以防止反序列化重新创建新的对象
- 非线程同步的方法不能使用
- 如果程序一开始要加载的资源太多，那么就应该使用懒加载
- 饿汉式如果是对象的创建需要配置文件就不适用
- 懒加载虽然好，但是静态内部类这种方式会引入编程复杂性

### 29. 饿汉式的缺点

上来就会把资源加载进来，造成一定情况的浪费

### 30. 懒汉式的缺点

写法复杂

### 31. 为什么要用double-check？不用就不安全吗？

### 32. 为什么双重检查模式要用volatile？

### 33. 应该如何选择？用哪种单例的实现方案最好？

枚举，防止反序列化破坏单例

### 34. 讲一讲什么是Java内存模型

主内存，本地内存
happen-before
volatile
synchronized
原子性

### 35. volatile和synchronized的异同

轻版的synchronized，没有累加操作

### 36. 什么是原子操作？Java中有哪些原子操作？生产对象的过程是不是原子操作？

新建一个空的Person对象
把这个对象的地址指向P
指向Person的构造函数

### 37. 什么是内存可见性

多层缓存造成你看不见我我看不见你的问题，JMM的抽象

### 38. 64位的double和long写入的时候是原子的吗

通常不需要考虑

### 39. 写一个必然死锁的例子。生产中什么场景下会发生死锁

### 40. 发生死锁必须满足的条件

互斥条件，请求与保持条件，不剥夺条件，循环等待条件

### 41. 如何定位死锁
jstack ThreadMXBean

### 42. 有哪些结局死锁问题的策略

避免策略：哲学家就餐的换手方案，转账换序方案
检测与恢复策略
鸵鸟策略

### 43. 讲一讲经典的哲学家就餐问题

### 44. 实际工程中如何避免死锁

### 45. 什么是活跃性问题？活锁、饥饿、和死锁有什么区别？




### 10. Java SE8和Java1.8和JDK 8什么关系

### 11. Join和sleep和wait期间线程的状态分别是什么？为什么？