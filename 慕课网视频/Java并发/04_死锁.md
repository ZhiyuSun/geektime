# 死锁

## 死锁是什么？有什么危害？

什么是死锁？
- 发生在并发中
- 互不相让：当两个（或更多）线程（或进程）相互持有对方所需要的资源，又不主动释放，导致所有人都无法继续前进，导致程序陷入无尽的阻塞，这就是死锁。

多个线程造成死锁的情况
- 如果多个线程之间的依赖关系是环形，存在环路的锁的依赖关系，那么也可能会发生死锁

拿到A想拿B
拿到B想拿C
拿到C想拿A

死锁的影响
- 死锁的影响在不同系统中是不一样的，这取决于系统对死锁的处理能力
    - 数据库中：检测并放弃事务
    - JVM中：无法自动处理（但是有检测的能力）

几率不高但危害大
- 不一定发生，但是遵守“墨菲定律”
- 一旦发生，多是高并发场景，影响用户多
- 整个系统崩溃、子系统崩溃、性能降低
- 压力测试无法找出所有潜在的死锁

发生死锁的例子
- 最简单的情况
- 实际生产中的例子：转账
- 模拟多人随机转账

分析
- 当类的对象flag=1时（T1），先锁定O1，睡眠500毫秒，然后锁定O2
- 而T1在睡眠的时候另一个flag=0的对象（T2）线程启动，先锁定O2,睡眠500毫秒，等待T1释放O1
- T1睡眠结束后需要锁定O2才能继续执行，而此时O2已被T2锁定
- T2睡眠结束后需要锁定O1才能继续执行，而此时O1已被T1锁定
- T1,T2相互等待，都需要对方锁定的资源才能继续执行，从而死锁

实际生产中的例子：转账
- 需要两把锁
- 获取两把锁成功，且余额大于0，则扣除转出人，增加收款人的余额，是原子操作
- 顺序相反导致死锁

模拟多人随机转账
- 5万人很多，但是依然会发生死锁，墨菲定律
- 复习：发生死锁几率不高但危害大

死锁的4个必要条件
- 互斥条件
- 请求与保持条件
- 不剥夺条件
- 循环等待条件

缺一不可，逐个分析之前的例子

## 如何定位死锁？

jstack
ThreadMXBean代码演示

## 修复死锁的策略

线上发生死锁应该怎么办？
- 线上问题都需要防患于未然，不造成损失地扑灭几乎已经是不可能
- 保存案发现场然后重启服务器
- 暂时保证线上服务的安全，然后在利用刚才保存的信息，排查死锁，修改代码，重新发版

常见修复策略
- 避免策略：哲学家就餐的换手方案，转账换序方案
- 检测与恢复策略：一段时间检测是否有死锁，如果有就剥夺某一个资源，来打开死锁
- 鸵鸟策略：鸵鸟这种动物在遇到危险的时候，通常就会把头埋在地上，这样一来它就看不到危险了。而鸵鸟策略的意思就是说，如果我们发生死锁的概率极其低，那么我们就直接忽略它，直到死锁发生的时候，再人工修复

死锁避免策略：
- 思路：避免相反的获取锁的顺序
- 转账是避免死锁
- 实际上不在乎获取锁的顺序
- 通过hashcode来决定获取锁的顺序、冲突时需要“加时赛”
- 有主键更方便

哲学家就餐问题

多种解决方案
- 服务员检查（避免策略）
- 改变一个哲学家拿叉子的顺序（避免策略）
- 餐票（避免策略）
- 领导调节（检测与恢复策略）

常见修复策略
- 避免策略：哲学家就餐的换手方案，转账换序方案
- 检测与恢复策略：一段时间检测是否有死锁，如果有就剥夺某一个资源，来打开死锁

死锁检测算法
- 允许发生死锁
- 每次调用锁都记录
- 定期检查“锁的调用链路图”中是否存在环路
- 一旦发生死锁，就用死锁恢复机制进行恢复

恢复方法1：进程终止
- 逐个终止线程，直到死锁消除
- 终止顺序：
    - 优先级（是前台交互还是后台处理）
    - 已占用资源，还需要的资源
    - 已经运行时间

恢复方法2：资源抢占
- 把已经分发出去的锁给收回来
- 让线程回退几步，这样就不用结束整个线程，成本比较低
- 缺点：可能同一个线程一直被抢占，那就造成饥饿

## 实际工程中如何避免死锁

1. 设置超时时间
- Lock的tryLock(long timeout, TimeUnit unit)
- synchronized不具备尝试锁的能力
- 造成超时的可能性多：发生了死锁、线程陷入死循环、线程执行很慢
- 获取锁失败：打日志，发报警邮件，重启等

2. 多使用并发类而不是自己设计锁
- ConcurrentHashMap,ConcurrentLinkedQueue,AtomicBoolean等
- 实际应用中java.util.concurrent.atomic十分有用，简单方便且效率比使用Lock更高
- 多用并发集合少用同步集合，并发集合比同步集合的扩展性更好
- 并发场景需要用到map，首先想到用ConcurrentHashMap

3. 尽量降低锁的使用粒度：用不同的锁而不是一个锁

4. 如果能使用同步代码块，就不使用同步方法：自己指定锁对象

5. 给你的线程起个有意义的名字：debug和排查时事半功倍，框架和JDK都遵守这个最佳实践

6. 避免锁的嵌套：MustDeadLock类

7. 分配资源前先看能不能收回来：银行家算法

8. 尽量不要几个功能用同一把锁：专锁专用

## 其他活性故障

- 死锁是最常见的活跃性问题，不过除了刚才的死锁之外，还有一些类似的问题，会导致程序无法顺利执行，统称为活跃性问题
- 活锁（LiveLock）
- 饥饿

活锁
- 死锁：每个哲学家都拿着左手的餐叉，永远都在等右边的餐叉（或者相反）
- 活锁：在完全相同的时刻进入餐厅，并同时拿起左边的餐叉，那么这些哲学家就会等待五分钟，同时放下手中的餐叉，再等5分钟，又同时拿起这些餐叉
- 在实际的计算机问题中，缺乏餐叉可以类比为缺乏共享资源

什么是活锁
- 虽然线程并没有阻塞，也始终在运行（所以叫做“活”锁，线程是“活”的），但是程序却得不到进展，因为线程始终重复做同样的事
- 如果这里死锁，那么就是这里两个人都始终不动一动，直到对方先抬头，他们之间不再说话了，只是等待
- 如果发生活锁，那么这里的情况就是，双方都不停地对对方说：你先起来吧，你先起来吧，双方都一直在说话，在运行
- 死锁和活锁的结果是一样的，就是谁都不能先抬头

如何解决活锁问题
- 原因：重试机制不变，消息队列始终重试，吃饭始终谦让
- 以太网的指数退避算法
- 加入随机因素

工程中的活锁实例：消息队列
- 策略：消息如果处理失败，就放在队列开头重试
- 由于依赖服务出了问题，处理该消息一直失败
- 没阻塞，但程序无法继续
- 解决：放到队列尾部、重试限制

饥饿
- 当线程需要某些资源（例如CPU），但是却始终得不到
- 线程的优先级设置的过于低，或者有某线程持有锁同时又无限循环从而不释放锁，或者某程序始终占用某文件的写锁
- 饥饿可能会导致响应性差：比如，我们的浏览器有一个线程负责处理前台响应（打开收藏夹等动作），另外的后台线程负责下载图片和文件、计算渲染等。在这种情况下，如果后台线程把CPU资源都占用了，那么前台线程将无法得到很好的执行，这会导致用户的体验很差

程序设计不应依赖于优先级
- 不同操作系统不一样
- 优先级会被操作系统改变

## 总结

