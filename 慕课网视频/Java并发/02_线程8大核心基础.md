# 线程8大核心基础知识

## 1. 实现多线程的方法到底是1种还是2种还是4种？

Oracle官方的文档是如何写的？
- 方法一：实现Runnable接口
- 方法二：继承Thread类

方法一（实现Runnable接口）更好
为什么？
- run方法应该跟业务逻辑是解耦的，不应该混为一谈，继承不好
- 去建独立的线程，损耗大，而利用Runnable接口，可以用线程池，节约资源
- java是单继承的，导致java无法去继承其他的类了，限制了可扩展性

两种方法的本质对比
- 方法一，最终调用target.run()
- 方法二，run()整个都被重写

总结：最精准的描述
- 通常我们可以分为两类，Oracle也是这么说的
- 准确的讲，创建线程只有一种方式那就是构造Thread列，而实现线程的执行单元有两种方式
    - 方法一：实现Runnable接口的run方法，并把Runnable实例传给Thread类
    - 方法二：重写Thread的run方法（继承Thread类）163

典型错误观点分析
- 线程池创建线程也算是一种新建线程的方式。
    - 看源码，也是用的new Thread
- 通过Callable和FutureTask创建线程，也算是一种新建线程的方式
    - 看类的结构，也是用的Runnable
- 匿名内部类
- 定时器
- lamba

多线程的实现方式，在代码中写法千变万化，但其本质万变不离其宗。

不可能有一个类实现线程就是一种方式。
外面的包装不会逃出最根本的创建线程的两个方法

## 2. 怎样才是正确的线程启动方式？

### start()和run()的比较

start()方法含义
- 启动新线程。调用start的顺序并不能决定线程真正执行顺序
- 准备工作。
- 不能重复start()。

（这部分有点难）

start()源码解析
- 启动新线程检查线程状态
- 加入线程组
- 调用start0()

run()源码解析
- 源码解析
- 两种情况

run()就是一个普普通通的线程，需要start()间接的去调用run()方法


## 3. 上山容易下山难——如何正确停止线程？（难点）

### 讲解原理

原理介绍：使用interrupt来通知，而不是强制
（想要停止线程，是如何通知线程停止，而不是强制让线程停止）

### 正确的停止方法：interrupt

- 通常线程会在什么情况下停止普通情况  RightWayStopThreadWithoutSleep
- 线程可能被阻塞  RightWayStopThreadWithSleep
- 如果线程在每次迭代后都阻塞
- while内try/catch的问题

### 实际开发中的两种最佳实践

- 优先选择：传递中断
- 不想或无法传递：恢复中断
- 不应屏蔽中断

run方法不能再往上抛出异常了
抛出异常或者自己处理中断

### 响应中断的方法总结列表

- Object.wait()/wait(long)/wait(long,int)
- Thread.sleep(long)/sleep(long, int)
- Thread.join()/join(long)/join(long,int)
- java.util.concurrent.BlockingQueue.take()/put(E)
- java.util.concurrent.locks.Lock.lockInterruptibly()
- java.util.concurrent.CountDownLatch.await()
- java.util.concurrent.CyclicBarrier.await()
- java.util.concurrent.Exchanger.exchange(V)
- ajva.nio.channels.Selector的相关方法

### 错误的停止方法

- 被弃用的stop,suspend和resume方法
    - Thread.stop()本质上是不安全的，停止线程会导致它解锁已锁定的所有监视器
    - suspend带着锁去休息，很容易造成死锁
- 用volatile设置boolean标记位
    - 看上去可行
    - 错误之处
    - 修正方案

正解是用interrupt方法，使得线程在wait时还能进行响应
看源码，interrupt0，但是是一个native方法

### 停止线程相关重要函数解析

判断是否已被中断的相关方法
- static boolean interrupted()
    - 不会清除中断状态
- boolean isInterrupted()
    - 会清除中断状态
- Thread.interrupted()的目的对象

## 4. 线程的一生——6个状态（生命周期）

### New

已创建但还没启动的新线程

Thread.start() 到达Runnable状态

### Runnable

一旦调用了start方法，线程就会进入Runnable状态。意味：可运行的

对于操作系统中的两种状态：ready和running

如果CPU资源被别人拿走了，还是runnable状态

Runnable执行完成到Terminated
进入Synchronized修饰的相关方法或代码块，进入被阻塞blocked
进入等待waiting的几种方式：
- Object.wait()
- Thread.join()
- LockSupport.park()
进入计时等待timed_waiting的几种方式：
- Thread.sleep(time)
- Object.wait(time)
- Thread.join(time)
- LockSupport.parkNanos(time)
- LockSupport.parkUntil(time)

### Blocked

仅仅针对进入synchronized代码块，另外的线程想拿锁但是拿不到

获得了monitor锁，进入可运行Runnable

### Waiting

进入Runnable
- Object.notify()
- Object.notifyAll()
- LockSupport.unpark()

### Timed Waiting

多了时间参数

进入Runnable
- 等待时间到
- Object.notify()
- Object.notifyAll()
- LockSupport.unpark()

### Terminated

回不去任何状态

状态转换图很牛逼
所有状态不能跳两步

### 阻塞状态

一般习惯而言，把Blocked，waiting,timed_waiting都被称为阻塞装填，不仅仅是Blocked
有的等待io操作，有的等待锁，有的等待wait

## 5. Thread和Object类中的重要方法详解

方法概览

Thread
- sleep 有很多重载方式
- join 等待其他线程执行完毕
- yield 放弃以及获取到的CPU资源
- currentThread 获取当前执行线程的引用
- start, run 启动线程相关
- interrupt 中断线程
- stop suspend resume 已废弃

Object
- wait notify notifyAll 让线程暂时休息和唤醒

### wait, notify，notifyAll方法详解

#### 作用、用法

阻塞阶段

控制一些线程休息或唤醒





## 6. 线程的各个属性

## 7. 未捕获异常如何处理？

## 8. 双刃剑：多线程会导致的问题