# 订单服务开发

## 1. 建model

订单表
订单商品表
- 存商品图片，价格，镜像

## 2. 定义proto

google.protobuf.Empty 修改的返回

## 3. 项目的其他部分

handler,setting,nacos

## 4. 写接口

创建购物车，需要合并已经存在的记录

更新购物车状态

删除购物车

## 5. 写订单的接口

订单列表，订单详情，订单状态

新建订单（非常复杂的逻辑）
- 价格-访问商品服务
- 库存的扣减-访问库存服务
- 订单基本信息表，订单的商品信息表
- 从购物车中获取选中的商品
- 从购物车中删除已购买的商品

consul.py里面的filter_service，get_host_port，去拿服务

构成grc的channel
grpc.insecure_channel()

把goods.proto拷贝过来

grpc底层支持了dns的resolver
但是python的grpc还做的不到位，所以自己实现

把库存的proto文件也复制过来

创建订单逻辑编写

要把整个过程在事务中完成，但其实已经调用了其他服务，跨服务了
扣减服务跨服务了暂时管不到
但是创建订单可以先用with做回滚，trycatch捕获异常，并且在exception里rollback

test/order.py里面的代码可以重点学习一下

调用接口，使用order_pb2_grpc.OrderStub(channel)

## 6. 订单服务的web层开发

order-web

srv_conn.go 连接各个服务

## 7. 写web层具体的业务逻辑

购物车列表页

添加商品到购物车
调用库存服务，检查库存

删除商品

interface断言，userId.(uint) ??

更新购物车

订单列表页

ctx.get("userId") 可以拿用户

订单详情接口

strconv.Atoi(id)

request := proto.OrderRequest{
    Id：int32(i)
}
global.OrderSrvClient.OrderDetail(context.Background(), &request)

??
好像不知道类型，可以定义为interface
goods := make([]interface{}, 0)

ctx.ShouldBindJSON(&orderForm)
表单验证

创建订单完，要返回支付宝支付的url

## 8. 接入支付宝

支付宝公钥私钥

如果两个密钥相同，就是对称加密，否则就是非对称加密

## 9. 用户操作服务，剩下的几个功能


## 10. 前后端联调

## 11. 事务和分布式事务

库存扣减和订单表不一致
- 事务性问题——分布式事务来解决
- 业务，下单不支付
    - 支付成功后扣减——用户体验不好
    - 订单超时（30min）——库存归还

**事务**

一组sql语句操作单元，组内所有SQL语句完成一个业务，如果整组成功：意味着全部SQL都实现；如果其中任何一个失败，意味着整个操作都失败。失败，意味着整个过程都是没有意义的。应该是数据库回到操作前的初始状态。这种特性，就叫“事务”。

**为什么存在事务**

- 失败后，可以回到开始位置
- 没都成功之前，别的用户（进程，会话）是不能看到操作内的数据修改的

**事务的ACID**

1. 原子性[atomicity]
功能不可再分，要么全部成功，要么全部失败

2. 一致性[consistency]

一致性是指数据处于一种语义上的有意义且正确的状态。一致性是对数据可见性的约束，保证在一个事务中的多次操作的数据中间状态对其他事务不可见的。因为这些中间状态，是一个过渡状态，与事务的开始状态和事务的结束状态是不一致的。

举个例子，张三给李四转账100元。事务要做的是从张三账户上减掉100元，李四账户上加上100元。一致性的含义是其他事务要么看到张三还没有给李四转账的状态，要么张三已经成功转账给李四的状态，而对于张三少了100元，李四还没加上100元这个中间状态是不可见的。

我们来看一下转账过程中可能存在的状态：

张三未扣减、李四未收到
张三已扣减、李四未收到
张三已扣减，李四已收到

上述过程中： 1. 是初始状态、2是中间状态、3是最终状态，1和3是我们期待的状态，但是2这种状态却不是我们期待出现的状态。 

那么反驳的声音来了：

要么转账操作全部成功，要么全部失败，这是原子性。从例子上看全部成功，那么一致性就是原子性的一部分咯，为什么还要单独说一致性和原子性？

你说的不对。在未提交读的隔离级别下是事务内部操作是可见的，明显违背了一致性，怎么解释？

好吧，需要注意的是：

原子性和一致性的的侧重点不同：原子性关注状态，要么全部成功，要么全部失败，不存在部分成功的状态。而一致性关注数据的可见性，中间状态的数据对外部不可见，只有最初状态和最终状态的数据对外可见
　　

3. 隔离性[isolation]

事务的隔离性是指多个用户并发访问数据库时，一个用户的事务不能被其它用户的事务所干扰，多个并发事务之间数据要相互隔离。

隔离性是多个事务的时候, 相互不能干扰，一致性是要保证操作前和操作后数据或者数据结构的一致性，而我提到的事务的一致性是关注数据的中间状态，也就是一致性需要监视中间状态的数据，如果有变化，即刻回滚

如果不考虑隔离性，事务存在3种并发访问数据问题，也就是事务里面的脏读、不可重复读、虚度/幻读

mysql的隔离级别：读未提交、读已提交、可重复读、串行化

4. 持久性[durability]

是事务的保证，事务终结的标志(内存的数据持久到硬盘文件中)

**分布式事务**

分布式事务顾名思义就是要在分布式系统中实现事务，它其实是由多个本地事务组合而成。

对于分布式事务而言几乎满足不了 ACID，其实对于单机事务而言大部分情况下也没有满足 ACID，不然怎么会有四种隔离级别呢？所以更别说分布在不同数据库或者不同应用上的分布式事务了。

**程序出哪些问题会导致数据不一致**

1. 网络问题 - 硬件故障、网络抖动、网络拥塞
- 没有发送出去
- 发送出去了，返回没有收到，导致以为出错了

2. 程序出错
- 代码异常
- 宕机
    -  断电
    - 系统问题 - 磁盘满了、电脑坏掉等

## 12. CAP和BASE理论

1. CAP理论

cap理论是分布式系统的理论基石

Consistency (一致性)：

“all nodes see the same data at the same time”,即更新操作成功并返回客户端后，所有节点在同一时间的数据完全一致，这就是分布式的一致性。一致性的问题在并发系统中不可避免，对于客户端来说，一致性指的是并发访问时更新过的数据如何获取的问题。从服务端来看，则是更新如何复制分布到整个系统，以保证数据最终一致。

Availability (可用性):

可用性指“Reads and writes always succeed”，即服务一直可用，而且是正常响应时间。好的可用性主要是指系统能够很好的为用户服务，不出现用户操作失败或者访问超时等用户体验不好的情况。

Partition Tolerance (分区容错性):

即分布式系统在遇到某节点或网络分区故障的时候，仍然能够对外提供满足一致性和可用性的服务。分区容错性要求能够使应用虽然是一个分布式系统，而看上去却好像是在一个可以运转正常的整体。比如现在的分布式系统中有某一个或者几个机器宕掉了，其他剩下的机器还能够正常运转满足系统需求，对于用户而言并没有什么体验上的影响。

如果你是一个分布式系统，那么你必须要满足一点：分区容错性

TeoremaCAP

Oracle

MySQL

NoSOL

Consistencia

MongoDB

HBase

Redis

CA

X

Toleranciaa

particiones

Disponibilidad

AP

NoSOL

CoachDB

Cassandra

DynamoDB


CA without P：如果不要求P（不允许分区），则C（强一致性）和A（可用性）是可以保证的。但放弃P的同时也就意味着放弃了系统的扩展性，也就是分布式节点受限，没办法部署子节点，这是违背分布式系统设计的初衷的。

CP without A：如果不要求A（可用），相当于每个请求都需要在服务器之间保持强一致，而P（分区）会导致同步时间无限延长(也就是等待数据同步完才能正常访问服务)，一旦发生网络故障或者消息丢失等情况，就要牺牲用户的体验，等待所有数据全部一致了之后再让用户访问系统。设计成CP的系统其实不少，最典型的就是分布式数据库，如Redis、HBase等。对于这些分布式数据库来说，数据的一致性是最基本的要求，因为如果连这个标准都达不到，那么直接采用关系型数据库就好，没必要再浪费资源来部署分布式数据库。

AP wihtout C：要高可用并允许分区，则需放弃一致性。一旦分区发生，节点之间可能会失去联系，为了高可用，每个节点只能用本地数据提供服务，而这样会导致全局数据的不一致性。典型的应用就如某米的抢购手机场景，可能前几秒你浏览商品的时候页面提示是有库存的，当你选择完商品准备下单的时候，系统提示你下单失败，商品已售完。这其实就是先在 A（可用性）方面保证系统可以正常的服务，然后在数据的一致性方面做了些牺牲，虽然多少会影响一些用户体验，但也不至于造成用户购物流程的严重阻塞。

**Base理论**

（实际开发中尽量满足base理论，而不是cap理论，cap做不到）

分布式系统中的一致性是 弱一致性 单数据库 mysql的一致性 强一致性

BASE是Basically Available（基本可用）、Soft state（软状态）和Eventually consistent（最终一致性）三个短语的缩写。BASE理论是对CAP中一致性和可用性权衡的结果，其来源于对大规模互联网系统分布式实践的总结， 是基于CAP定理逐步演化而来的。BASE理论的核心思想是：即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性。接下来看一下BASE中的三要素：

1、基本可用

基本可用是指分布式系统在出现不可预知故障的时候，允许损失部分可用性—-注意，这绝不等价于系统不可用。比如：

（1）响应时间上的损失。正常情况下，一个在线搜索引擎需要在0.5秒之内返回给用户相应的查询结果，但由于出现故障，查询结果的响应时间增加了1~2秒

（2）系统功能上的损失：正常情况下，在一个电子商务网站上进行购物的时候，消费者几乎能够顺利完成每一笔订单，但是在一些节日大促购物高峰的时候，由于消费者的购物行为激增，为了保护购物系统的稳定性，部分消费者可能会被引导到一个降级页面

2、软状态

软状态指允许系统中的数据存在中间状态，并认为该中间状态的存在不会影响系统的整体可用性，即允许系统在不同节点的数据副本之间进行数据同步的过程存在延时

3、最终一致性

最终一致性强调的是所有的数据副本，在经过一段时间的同步之后，最终都能够达到一个一致的状态。因此，最终一致性的本质是需要系统保证最终数据能够达到一致，而不需要实时保证系统数据的强一致性。总的来说，BASE理论面向的是大型高可用可扩展的分布式系统，和传统的事物ACID特性是相反的，它完全不同于ACID的强一致性模型，而是通过牺牲强一致性来获得可用性，并允许数据在一段时间内是不一致的，但最终达到一致状态。但同时，在实际的分布式场景中，不同业务单元和组件对数据一致性的要求是不同的，因此在具体的分布式系统架构设计过程中，ACID特性和BASE理论往往又会结合在一起。

一句话：CAP就是告诉你：想要满足C、A、P就是做梦，BASE才是你最终的归宿

## 13. 分布式事务

**两/三阶段提交**

两阶段提交（2PC, Two-phase Commit）
TCC 补偿模式
基于本地消息表实现最终一致性
最大努力通知
基于可靠消息最终一致性方案 
两阶段提交（2PC）
两阶段提交又称2PC,2PC是一个非常经典的中心化的原子提交协议。

这里所说的中心化是指协议中有两类节点：一个是中心化协调者节点（coordinator）和N个参与者节点（partcipant）。

两个阶段：第一阶段：投票阶段 和第二阶段：提交/执行阶段。

举例 订单服务A，需要调用 支付服务B 去支付，支付成功则处理购物订单为待发货状态，否则就需要将购物订单处理为失败状态。

那么看2PC阶段是如何处理的

1、第一阶段：投票阶段
 
第一阶段主要分为3步

1）事务询问

协调者 向所有的 参与者 发送事务预处理请求，称之为Prepare，并开始等待各 参与者 的响应。

2）执行本地事务

各个 参与者 节点执行本地事务操作,但在执行完成后并不会真正提交数据库本地事务，而是先向 协调者 报告说：“我这边可以处理了/我这边不能处理”。.

3）各参与者向协调者反馈事务询问的响应

如果 参与者 成功执行了事务操作,那么就反馈给协调者 Yes 响应,表示事务可以执行,如果没有 参与者 成功执行事务,那么就反馈给协调者 No 响应,表示事务不可以执行。

第一阶段执行完后，会有两种可能。1、所有都返回Yes. 2、有一个或者多个返回No。

2、第二阶段：提交/执行阶段（成功流程）
成功条件：所有参与者都返回Yes。

 
第二阶段主要分为两步

1)所有的参与者反馈给协调者的信息都是Yes,那么就会执行事务提交

协调者 向 所有参与者 节点发出Commit请求.

2)事务提交

参与者 收到Commit请求之后,就会正式执行本地事务Commit操作,并在完成提交之后释放整个事务执行期间占用的事务资源。

3、第二阶段：提交/执行阶段（异常流程）
异常条件：任何一个 参与者 向 协调者 反馈了 No 响应,或者等待超时之后,协调者尚未收到所有参与者的反馈响应。

 
异常流程第二阶段也分为两步

1)发送回滚请求

协调者 向所有参与者节点发出 RoollBack 请求.

2)事务回滚

参与者 接收到RoollBack请求后,会回滚本地事务。

4、2PC缺点
通过上面的演示，很容易想到2pc所带来的缺陷

1）性能问题

无论是在第一阶段的过程中,还是在第二阶段,所有的参与者资源和协调者资源都是被锁住的,只有当所有节点准备完毕，事务 协调者 才会通知进行全局提交，

参与者 进行本地事务提交后才会释放资源。这样的过程会比较漫长，对性能影响比较大。

2）单节点故障

由于协调者的重要性，一旦 协调者 发生故障。参与者 会一直阻塞下去。尤其在第二阶段，协调者 发生故障，那么所有的 参与者 还都处于

锁定事务资源的状态中，而无法继续完成事务操作。（虽然协调者挂掉，可以重新选举一个协调者，但是无法解决因为协调者宕机导致的参与者处于阻塞状态的问题）

2PC出现单点问题的三种情况

(1)协调者正常,参与者宕机

由于 协调者 无法收集到所有 参与者 的反馈，会陷入阻塞情况。

解决方案:引入超时机制,如果协调者在超过指定的时间还没有收到参与者的反馈,事务就失败,向所有节点发送终止事务请求。

(2)协调者宕机,参与者正常

无论处于哪个阶段，由于协调者宕机，无法发送提交请求，所有处于执行了操作但是未提交状态的参与者都会陷入阻塞情况.

解决方案:引入协调者备份,同时协调者需记录操作日志.当检测到协调者宕机一段时间后，协调者备份取代协调者，并读取操作日志，向所有参与者询问状态。

(3)协调者和参与者都宕机

发生在第一阶段： 因为第一阶段，所有参与者都没有真正执行commit，所以只需重新在剩余的参与者中重新选出一个协调者，新的协调者在重新执行第一阶段和第二阶段就可以了。
2)发生在第二阶段 并且 挂了的参与者在挂掉之前没有收到协调者的指令。也就是上面的第4步挂了，这是可能协调者还没有发送第4步就挂了。这种情形下，新的协调者重新执行第一阶段和第二阶段操作。

3)发生在第二阶段 并且 有部分参与者已经执行完commit操作。就好比这里订单服务A和支付服务B都收到协调者 发送的commit信息，开始真正执行本地事务commit,但突发情况，Acommit成功，B确挂了。这个时候目前来讲数据是不一致的。虽然这个时候可以再通过手段让他和协调者通信，再想办法把数据搞成一致的，但是，这段时间内他的数据状态已经是不一致的了！ 2PC 无法解决这个问题。

（有性能问题，加锁，一般不会使用）

**tcc分布式事务**

try, confirm或者cancel

confirm和cancel出错的概率比较低

优缺点：

优点：
1.解决了跨服务的业务操作原子性问题，例如组合支付，订单减库存等场景非常实用
2.TCC的本质原理是把数据库的二阶段提交上升到微服务来实现，从而避免了数据库2阶段中锁冲突的长事务低性能风险。
3.TCC异步高性能，它采用了try先检查，然后异步实现confirm，真正提交的是在confirm方法中。


缺点：
1.对微服务的侵入性强，微服务的每个事务都必须实现try，confirm，cancel等3个方法，开发成本高，今后维护改造的成本也高。
2.为了达到事务的一致性要求，try，confirm、cancel接口必须实现等幂性操作。
（定时器+重试）
3.由于事务管理器要记录事务日志，必定会损耗一定的性能，并使得整个TCC事务时间拉长，建议采用redis的方式来记录事务日志。
4.tcc需要通过锁来确保数据的一致性，会加锁导致性能不高

**基于本地消费表的最终一致性**

虽然当前还没有数据一致，但是最终一定会一致

但是发送给mq的网络拥塞难以解决

加本地消息表+定时任务

**基于可靠消息的最终一致性**

基于事务消息最终一致性

1. 事务消息
2. 事务消息回查

1. 业务逻辑简单
2. 高并发

rocketmq的高并发能力比rabbitmq高一个级别

**最大努力通知方案**

不断重试

提供查询接口
