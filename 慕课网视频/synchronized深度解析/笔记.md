# Synchronaized深度解析

## Synchronized的作用

翻译：同步方法支持一种简单的策略来防止线程干扰和内存一致性错误：
如果一个对象对多个线程可见，则对该对象变量的所有读取或写入都是通过同步方法完成的。

总结：能够保证在同一时刻最多只有一个线程执行该代码段，以达到保证并发安全的效果。

## Synchronized的地位

- 是Java的关键字，被Java语言原生支持
- 是最基本的互斥同步手段
- 是并发编程中的元老级角色，是并发编程的必须内容

## 不使用并发手段会有什么后果？

count++，它看上去只是一个操作，实际上包含了三个动作：
- 读取count
- 将count加1
- 将count的值写入到内存中

## Synchronized的两个用法

对象锁
- 包括方法锁（默认锁对象为this当前实例对象）和同步代码块锁（自己指定锁对象）

类锁
- 指synchronized修饰静态的方法或指定锁为Class对象

第一个用法：对象锁

代码块形式：手动指定锁对象
方法锁形式：Synchronized修饰普通方法，锁对象默认为this

第二个用法：类锁

概念（重要）：Java类可能有很多个对象，但只有1个Class对象
本质：所以所谓的类锁，不过是Class对象的锁而已
用法和效果：类锁只能在同一时刻被一个对象拥有

形式1：synchronized加在static方法上
形式2：synchronized(*.class)代码块

## 多线程访问同步方法的7种情况

1. 两个线程同时访问一个对象的同步方法

参考synchronizedObjectMethod3

2. 两个线程访问的是两个对象的同步方法

synchronized不起作用，因为锁的是不同的实例

3. 两个线程访问的是synchronized的静态方法

SynchronizedClassStatic4
一个一个执行，锁生效

4. 同时访问同步方法与非同步方法

synchronized关键字只作用于被修饰的一个方法中
SynchronizedYesAndNo6
不生效

5. 访问同一个对象的不同的普通同步方法

没有办法同时运行  SynchronizedDifferentMethod7

6. 同时访问静态synchronized和非静态synchronized方法

不生效

7. 方法抛出异常后，会释放锁

### 总结：3点核心思想

1. 一把锁只能同时被一个线程获取，没有拿到锁的线程必须等待（对应第1、5中情况）；
2. 每个实例都对应有自己的一把锁，不同实例之间不糊影响；例外：锁对象是*.class一级synchronized修饰的是static方法的时候，所有对象共用同一把类锁（对应2,3,4,6中情况）
3. 无论是方法正常执行完毕或者方法抛出异常，都会释放锁（对应第7种情况）

如果synchronized方法调用了另一个非synchronized方法，第二个方法不是线程安全的

## Synchronized性质

### 可重入

什么是可重入：指的是同一线程的外层函数获得锁之后，内层函数可以直接再次获取该锁

拿摇号举例，摇到一个号，只能给一辆车上牌照，就是不可重入。摇号就是线程，我就是锁。可以申请无限量的牌照，就是可重入

好处：
- 避免死锁
- 提升封装性

粒度：
线程而非调用（用3种情况来说明和pthread的区别）
- 情况1：证明同一个方法是可重入的
- 情况2：证明可重入不要求是同一个方法
- 情况3：证明可重入不要求是同一个类中的

粒度是线程范围，只要需要的锁依然是手中的这把锁，可以直接去完成这件事情，不要释放出来

### 不可中断

一旦这个锁已经被别人获得了，如果我还想获得，我只能选择等待或者阻塞，直到别的线程释放这个锁。
如果别人永远不释放锁，那么我只能永远地等下去。

相比之下，未来会介绍的Lock类，可以拥有中断的能力，第一点，如果我觉得我等的时间太长了，有权中断现在已经获取到锁的线程的执行；第二点，如果我觉得我等待的时间太长了不想再等了，也可以退出。

## 加锁和释放锁的原理

### 加锁和释放锁的原理：现象、时机、深入JVM看字节码

现象

获取和释放锁的时机：内置锁

等价代码

深入JVM看字节码
- 锁是存储在Java对象头中
javac Decompilation14
javap -verbose Decompilation14.class
背后 monitorenter, monitorexit指令

### 可重入原理：加锁次数计数器

JVM负责跟踪对象被加锁的次数
线程第一次给对象加锁的时候，计数变为1。每当这个相同的线程在此对象上在此获得锁时，计数会递增。
每当任务离开时，计数递减，当计数为0的时候，锁被完全释放。

### 保证可见性的原理：内存模型

#### Java内存模型

线程A——本地内存A——共享变量的副本

线程B——本地内存B——共享变量的副本

主内存——共享变量

线程之间的通信：线程A向B发送数据
线程A把自己修改的变量内容放到主内存中，线程B再去主内存中读取。JMM来控制

JMM正是通过控制线程本地内存和主线程之间的交互，来提供内存可见性的保证

Synchronized如何做到可见性实现
一旦代码块被Synchronized关键字所修饰，执行完毕之后，对锁对象的任何修改，都要在释放锁之前，从线程内存写入到主内存之中。
不会存在线程内存和主内存不一致的情况。

## Synchronized的缺陷

1. 效率低：锁的释放情况少，试图获得锁时不能设定超时、不能中断一个正在试图获得锁的线程

锁的释放情况少
- 执行完了
- 程序异常

试图获得锁时不能设定超时
- 只能干巴巴的等待
- 相比于Lock，可以设置等待时间

2. 不够灵活（读写锁更灵活）：加锁和释放的时机单一，每个锁仅有单一的条件（某个对象），可能是不够的

3. 无法知道是否成功获取到锁

## 常见面试问题

1. Synchronized的使用注意点

锁对象不能为空：必须是一个实例对象，不能是一个空对象，锁的信息是保存在对象头中的
作用域不宜过大：影响程序执行速度
避免死锁

2. 如何选择Lock和Synchronized关键字？

如果可以，这两个都不使用，而是使用JUC的类，不需要自己去做同步工作
如果Synchronized在代码中适用，就优先使用，可以减少代码量，减少出错几率
如果特别需要Lock独有特性，才使用Lock

3. 多线程访问同步方法的各种具体情况

## 思考题

1. 多个线程等待同一个synchronized锁的时候，JVM如何选择下一个获取锁的是哪个线程？

随机不可控

2. Synchronized使得同时只有一个线程可以执行，性能较差，有什么办法可以提升性能？

控制范围，满足需求的情况下足够小
使用其他权限的lock，读写锁

3. 我想要更灵活地控制锁的获取和释放，怎么办？

4. 什么是锁的升级、降级？什么是JVM里的偏斜锁、轻量级锁、重量级锁？

JVM会优化，使性能大幅上涨，在对象头里做优化

## 总结

一句话介绍Synchronized

JVM会自动通过使用monitor来加锁和解锁，保证了同时只有一个线程可以执行指定代码，从而保证了线程安全，同时具有可重入和不可中断的性质。


