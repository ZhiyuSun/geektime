# 多线程实践

## Python线程初体验

**获取进程/线程id**

当Python只有一个线程时，进程ID就等于线程ID

ps -ef | grep python
查看进程

ps -T -p pid
查看线程，PID进程ID，SPID线程ID

进程的主线程ID=进程ID

**生产者-消费者模型**

按同样的命令查看

进程ID 9289
线程ID 9289,9290,9291
进程有三个线程在跑，一个主线程，一个是生产者，一个是消费者
threading.active_acount()
线程当前的活跃数量

**总结**

刚开始只有1个主线程

启动了生产者和消费者后，就有3个线程在运行

## 实现单线程下载器

下载模块，哈希模块，存储模块
调度模块

图片下载器

类里面，_xxx 私有函数

## 模块性能分析-并行化运行的可行性

网络，cpu，磁盘
统计这三部分的时间

模块间串行
模块内并行

## 线程池的原理与实践

什么是线程池
- 线程池是存放多个线程的容器
- CPU调度线程执行后不会销毁线程
- 将线程放回线程池重复利用

为什么使用线程池
- 线程是稀缺资源，不应该频繁创建和销毁（内核级线程要频繁的在内核态创建和销毁，会占用比较多的CPU的时间，使得程序的运行效率会降低）
- 架构解耦，线程创建和业务处理解耦，更加优雅
- 线程池是使用多线程的最佳实践

## 线程池的原理

利用列表和队列模拟线程池
simpleThreadPool.py

## 线程池标准库ThreadPoolExecutor

from concurrent.futures import ThreadPoolExecutor

future获取结果   
future = tp.submit(_task)

threadpoolexecutortest.py

## 线程池改造优化模块的性能

对网络时间有所提升，70%

但是磁盘模块和哈希模块反而耗时变多了，分别是-14%，-70%

## Python多线程的局限性

可能的问题？
- 统计逻辑错误
- CPU核数
- 线程数过多，相互竞争损耗

一组图标，非常有说明性
cpu核数增加，线程数不变

结论：
- 多线程对下载模块有明显加速作用
- 多线程对哈希模块只有副作用
- 多线程对存储模块有明显加速作用

线程数增加，CPU核数不变
哈希模块也不增加

多线程加速为什么对哈希模块不生效？
- python多线程是伪多线程（只是在并发，并没有在并行）

哈希模块——CPU密集型
下载模块，存储模块——IO密集型





