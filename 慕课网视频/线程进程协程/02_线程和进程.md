# 线程和进程

## 操作系统的进程详解

process进程

### 进程存在的必要性

操作系统统一管理着计算机资源
操作系统实现了对计算机资源的抽象
操作系统提供了用户与计算机之间的接口

进程存在的必要性：
程序切换：隔离资源、运行环境，提升资源利用率

进程是系统进行资源分配和调度的基本单位
进程作为程序独立运行的载体保障程序正常执行
进程的存在使得操作系统资源的利用率大幅提升

### 进程的形态

32位系统进程的4G虚拟空间。kernel  User
Kernel  进程控制块（PCB）
- 操作系统内核的一种数据结构
- 管理进程，记录进程运行状态
- 每个进程都拥有自己的进程控制块

进程控制块
- 标识符：唯一标记一个进程
- 状态：记录进程运行的当前状态
- 优先级
- 程序计数器：记录下一条指令的地址
- 内存指针：指令、数据的内存地址
- 上下文数据：运行状态下使用的数据
- IO状态信息：文件、设备占用情况
- 记账信息：处理器时间、时钟统计

进程的形态
- 用于描述和控制进程运行的通用数据结构
- 记录进程当前状态和控制进程运行的全部信息
- PCB使得进程可以能够独立的运行

用户空间也保存着进程的数据
- 栈：局部变量，函数参数，返回地址等
- 堆：动态分配的内存
- BSS段：未初始化或初值为0的全局变量和静态局部变量
- 数据段：已初始化且初值为0的全局变量和静态局部变量
- 代码段：可执行代码、字符串字面值、只读变量

## 进程的五状态模型

就绪
- 当进程被分配到除CPU以外所有必要的资源后
- 只要再获得CPU的使用权，就可以立即运行
- 其他资源都准备好、只差CPU资源的状态为就绪状态
- 在一个系统中多个处于就绪状态的进程通常排成一个队列（就绪队列）

执行
- 进程获得CPU，其程序正在执行成为执行状态
- 在单处理机中，在某个时刻只能有一个进程是处于执行状态

阻塞
- 进程因某种原因如：其他设备未就绪而无法继续执行
- 从而放弃CPU的状态成为阻塞状态
- （阻塞队列）


就绪——进程调度——执行——时间片完——就绪
执行——IO请求——阻塞
阻塞——IO完成——就绪


创建
分配PCB——插入就绪队列
- 创建进程时拥有PCB但其他资源尚未就绪的状态称为创建状态
- 操作系统提供fork函数接口创建进程

终止
系统清理——PCB归还
- 进程结束由系统清理或者归还PCB的状态称为终止状态

创建——创建完成——就绪
执行——执行完成——终止

## 进程的调度方式

调度算法
- 前提：多道程序设计、CPU资源有限
- CPU资源如何公平分配
- 进程的优先级是有差异的

非抢占式调度
- 当前进程主动放弃CPU
抢占式调度
- 进程拥有优先级
- 优先级作为调度的参考
- 允许中断当前执行进程

调度算法
- 先来先服务调度算法
- 最短作业优先算法
    - 预估进程剩余所需运行时间
    - 维护的就绪队列始终规模较小，提高系统吞吐量
    - 不利于长进程的运行，估算可能不准确
- 最高响应比优先算法
    - 考虑执行时间、等待时间
    - 响应比，rp=(等待时间+预计执行时间)/执行时间=响应时间/执行时间
- 时间片轮转调度算法
    - 固定的时间片


## 线程存在的意义

比进程更小的独立运行的基本单位——线程
提高系统内程序并发执行的程度

一个进程可包含多个线程

轻装上阵，轻量级进程

线程是什么
- 线程是操作系统进行运行调度的最小单位
- 进程是系统进行资源分配和调度的基本单位
- 包含在进程之中，是进程中实际运行工作的单位
- 一个进程可以并发多个线程，每个线程执行不同的任务
- 进程控制块（PCB）——线程控制块（TCB）

## 进程与线程的关系

Process, Thread

进程的线程共享进程资源

        进程                    线程
资源    资源分配的基本单位      不拥有资源
调度    调度开销大              调度开销小
系统开销    进程系统开销大            线程系统开销小
并发性      进程间并发              进程间并发，进程内多线程并发


阶乘程序，在多核CPU上跑，只占了50%，后面会进行改造，利用上多核

## 线程的实现方式

### 内核支持线程

KST

操作系统在内核态完成

一对一关系

- 调度灵活
- 内核线程切换成本高

### 用户级线程

管理工作发生在用户态

内核无法感知用户级线程的存在
多对一的关系

- 由用户自行调度，内核无法干涉
- 内核线程阻塞，所有线程无法运行

只要用户级线程对于的内核级线程阻塞了，该内核级线程对应的用户级线程无法执行

### 组合方式线程

多对多关系

### 常见编程语言的线程模型

c/c++
- 操作系统由C/C++实现
- 使用原生thread
- 一对一关系

Java
- Thred，Runnable对象
- JVM封装操作系统thread
- 一对一关系

JavaScript
- JavaScript是单线程的
- async、await、yield等协程关键字，实现用户级线程
- 一对多

go
- 典型的组合方式
- golang的G-P-M模型
- 性能强大，并发效率高
- 组合方式

Python
- 组合方式，提供Thread线程对象
- yield,await,async等关键字
- asyncio等携程库
- 组合方式

## 进程与线程上下文切换

### 什么是上下文切换

上下文包括
- 寄存器级上下文（cpu的运算器，控制器，高速缓存）
- 用户级上下文（缓存，主存，辅存）
- 系统级上下文

上下文切换的步骤
- 准备就绪进程运行数据
- 保存当前进程运行装填
- 迁出当前进程数据
- 迁入就绪进程数据
- 恢复就绪进程上一次运行状态
- 就绪进程开始运行

### 上下文切换的成本

sar -w 1 10
平均每秒上下文切换次数

切换一次大概是2us-5us

每个核1s就是25ms左右

开始比较成本

进程的线程共享进程资源

- 同一个进程的多线程之间的切换
- 不同进程的线程之间切换（进程切换）

进程切换的成本要远大于线程切换成本的

## 探索协程的本质

Coroutine

协作式线程

比线程更小的粒度
运行效率更高
可以支持更高的并发

进程包含线程，线程包含协程

协程的本质就是用户级线程

协程对比线程，即用户级线程对比内核级线程

linux top命令，后台服务多线程并发，cpu16核32线程，一般都是内核级线程


例子
goto语句，无条件转移语句
生产者-消费者模型（类比协程在用户态调度）

协程为什么叫做协作式线程？
- 由用户自行调度，内核无法干涉

协作，让步

内核感知到的依然是串行

协程优缺点
- 调度、切换、管理更加轻量
- 内核无法感知协程的存在（对内核来说只有一个线程，当一个协程阻塞，所有协程都阻塞了）

