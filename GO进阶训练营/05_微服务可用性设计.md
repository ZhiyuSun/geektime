# 微服务可用性设计

## 隔离

隔离，本质上是对系统或资源进行分割，从而实现当系统发生故障时能限定传播范围和影响范围，即发生故障后只有出问题的服务不可用，保证其他服务仍然可用。
服务隔离
- 动静分离、读写分离
轻重隔离
- 核心、快慢、热点
物理隔离
- 线程、进程、集群、机房

false sharding: https://www.cnblogs.com/cyfonly/p/5800758.html

## 超时控制

超时控制，我们的组件能够快速失效（fail fast），因为我们不希望等到断开的实例直到超时。没有什么比挂起的请求和无响应的界面更令人失望。这不仅浪费资源，而且还会让用户体验变得更差。我们的服务是互相调用的，所以在这些延迟叠加前，应该特别注意防止那些超时的操作。
- 网路传递具有不确定性。
- 客户端和服务端不一致的超时策略导致资源浪费。
- “默认值”策略。
- 高延迟服务导致 client 浪费资源等待，使用超时传递: 进程间传递 + 跨进程传递。
超时控制是微服务可用性的第一道关，良好的超时策略，可以尽可能让服务不堆积请求，尽快清空高延迟的请求，释放 Goroutine。


api定义里设置latency SLO

## 过载保护

漏桶：流出速率恒定
令牌桶：流入速度恒定

kratos/pkg/rate_limit

## 限流

限流是指在一段时间内，定义某个客户或应用可以接收或处理多少个请求的技术。例如，通过限流，你可以过滤掉产生流量峰值的客户和微服务，或者可以确保你的应用程序在自动扩展（Auto Scaling）失效前都不会出现过载的情况。

分布式限流

断路器（Circuit Breakers）: 为了限制操作的持续时间，我们可以使用超时，超时可以防止挂起操作并保证系统可以响应。因为我们处于高度动态的环境中，几乎不可能确定在每种情况下都能正常工作的准确的时间限制。断路器以现实世界的电子元件命名，因为它们的行为是都是相同的。断路器在分布式系统中非常有用，因为重复的故障可能会导致雪球效应，并使整个系统崩溃。

## 降级

在BFF层做，相对比较合适
降级不应该被经常触发
演练也很重要

rpc调用失败，走到fallback的代码

## 重试

避免重试的级联风暴

## 负载均衡

通常N+2个主机

## 最佳实践

变更管理
避免过载
依赖管理
优雅降级
重试退避
超时控制
极限压测+故障演练
扩容+容器+清除有害流量

## 直播答疑

http2.0

p6升p7，一定是有业务价值和业务产出，不是纯技术的输出
P7升p8，有影响力+战功

普罗米修斯+grafana 告警

毛大是先深度，后广度的

分布式限流，b站用的youtube的doorman，闭源

LVS+OSPF架构

online ddl

Omini 画系统设计图的工具

mysql是用二阶段提交，tcc，消息队列异步，seeta来做

一个团队里，只要保证10%的员工不走就没问题





## 问题

1. b站是怎么做分布式事务的。超时
2. 老师这周的课很令我大开眼界，但是我平时项目做的比较简单，听完课后对很多内容也只是有概念性的理解，缺少实践，如果面试时跟面试官讲这些概念，面试官会认吗
3. 老师，你们做分布式限流，有一款分布式限流框架叫sentinel，不知道老师有没有了解？
4. 